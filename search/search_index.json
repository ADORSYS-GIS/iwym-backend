{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Docs for IWYM","text":""},{"location":"ARC42/","title":"ARC42 Template for IWYM Backend","text":""},{"location":"ARC42/#1-introduction-and-goals","title":"1. Introduction and Goals","text":""},{"location":"ARC42/#project-overview","title":"Project Overview","text":"<p>This project aims to develop a local payment processor akin to Stripe, specifically tailored for the Cameroonian market. The solution will empower merchants to accept payments via local mobile money platforms such as MTN Mobile Money and Orange Money. Initially scoped as a proof of concept (PoC), this system will support additional features and services, such as cross-border payments and multi-tenancy, to accommodate future expansion.</p> <p>The platform provides merchants with a RPC API for payment processing, SDKs and plugins for easy integration, and a dashboard interface to monitor transactions, manage funds, and perform financial operations. Our primary focus is a scalable, secure, and cost-effective solution that leverages cloud-native features and integrates with Kubernetes (EKS) for autoscaling and resilience.</p>"},{"location":"ARC42/#primary-goals","title":"Primary Goals","text":"<ol> <li>Simplify Payment Integration: Provide developers and merchants with API and SDK tools for easy implementation    of mobile payments and support for plug-and-play integrations.</li> <li>Ensure Security: Implement end-to-end encryption, API key and JWT authentication, and a **double-entry ledger    ** for secure and traceable transactions.</li> <li>Scale with Demand: Utilize Kubernetes to dynamically scale service instances, managing traffic spikes and high    transaction volumes.</li> <li>Optimize Cost Efficiency: Transition fully to Rust-based high-performance backend and PostgreSQL.</li> <li>Reproducible Development Environments: Use Docker to ensure consistent and reproducible development setups.</li> </ol>"},{"location":"ARC42/#non-goals","title":"Non-Goals","text":"<ul> <li>No credit card support: This phase focuses on mobile money payments only.</li> <li>No international payment support: Local transactions only; international expansion may be scoped later.</li> </ul>"},{"location":"ARC42/#2-constraints","title":"2. Constraints","text":""},{"location":"ARC42/#technology-constraints","title":"Technology Constraints","text":"<ul> <li>Backend: Built entirely in Rust, supporting RPC APIs for high performance and efficiency.</li> <li>Frontend: Built with Next.js for a seamless, responsive merchant dashboard, hosted on Vercel or   Kubernetes.</li> <li>Database: PostgreSQL for structured data storage, including multi-tenant support and indexing for efficient   query performance.</li> <li>Authentication: Keycloak for robust, centralized authentication and authorization management.</li> <li>Storage: S3-compatible storage like Minio for managing immutable data such as receipts, invoices,   proof-of-purchase PDFs, user-uploaded documents, snapshots, and backups.</li> </ul>"},{"location":"ARC42/#regulatory-constraints","title":"Regulatory Constraints","text":"<ul> <li>Financial Compliance: Comply with Cameroonian financial regulations, including obtaining the necessary   licenses to operate as a payment processor.</li> <li>Data Privacy: Ensure compliance with data protection standards (GDPR or similar) to secure customer and   transaction data.</li> </ul>"},{"location":"ARC42/#operational-constraints","title":"Operational Constraints","text":"<ul> <li>Budget Optimization: Use cost-effective solutions such as managed Kubernetes (AWS EKS or GKE) with optimized cloud   infrastructure and autoscaling to meet fluctuating demand.</li> </ul>"},{"location":"ARC42/#3-context-and-scope","title":"3. Context and Scope","text":""},{"location":"ARC42/#system-context","title":"System Context","text":"<p>The local payment processor acts as an intermediary between merchants and mobile money providers (MTN MoMo and Orange Money). It provides API endpoints for merchants to initiate transactions, a dashboard for monitoring and managing accounts, and backend services to handle webhooks, payment processing, and payouts.</p>"},{"location":"ARC42/#primary-actors","title":"Primary Actors","text":"<ol> <li>Merchants: Businesses or individuals utilizing the API for payment processing, integrating it with their    platforms, and managing their funds via the dashboard.</li> <li>Customers: Individuals completing payments using their mobile money wallets.</li> <li>Administrator: Internal user responsible for account validation, handling sandbox-to-production transitions    , and merchant account management.</li> <li>Payment Providers: External systems (e.g., MTN MoMo, Orange Money) that process transactions and provide payment    confirmations.</li> </ol>"},{"location":"ARC42/#4-solution-strategy","title":"4. Solution Strategy","text":""},{"location":"ARC42/#technology-choices","title":"Technology Choices","text":"<ul> <li>Backend: Fully built in Rust for RPC APIs.</li> <li>Frontend: Next.js to build a dynamic, interactive dashboard with real-time transaction visibility.</li> <li>Database: PostgreSQL as the primary database, supporting structured data and multi-tenant operations.</li> <li>Authentication: Keycloak for centralized, flexible authentication and authorization.</li> <li>Storage: S3-compatible storage (Minio) for assets such as transaction records, invoices, proof of purchase,   and backups.</li> </ul>"},{"location":"ARC42/#security-strategy","title":"Security Strategy","text":"<ol> <li>Authentication and Authorization:<ul> <li>Centralized management using Keycloak for JWT authentication and API key-based access for merchants.</li> <li>RBAC (Role-Based Access Control) to manage permissions across different roles (Admin, Merchant, Client).</li> </ul> </li> <li>Encryption: All communication (internal and external) secured with HTTPS and mTLS (for Kubernetes services).</li> <li>Input Validation and Rate Limiting: Enforce validation to mitigate injection attacks and implement rate limiting    to avoid abuse.</li> </ol>"},{"location":"ARC42/#resilience-strategy","title":"Resilience Strategy","text":"<ul> <li>Global Error Handling: Implement centralized error handling across services and integrate with Sentry for   error tracking.</li> <li>Auto-Scaling and Failover: Deploy with Kubernetes HPA to handle scaling and cluster failover to improve   availability.</li> </ul>"},{"location":"ARC42/#ssdlc-practices","title":"SSDLC Practices","text":"<ul> <li>Static Code Analysis: Integrate tools like Clippy (for Rust) to enforce coding standards and catch vulnerabilities   early.</li> <li>Dependency Management: Regularly update dependencies to minimize risks from third-party libraries.</li> <li>Threat Modeling: Conduct threat modeling exercises for critical services, focusing on payment workflows.</li> <li>Secure Code Reviews: Enforce mandatory peer reviews for code changes.</li> <li>Automated Testing: Comprehensive unit, integration, and regression tests for all services.</li> </ul>"},{"location":"ARC42/#5-building-block-view-architecture-overview","title":"5. Building Block View (Architecture Overview)","text":""},{"location":"ARC42/#core-components","title":"Core Components","text":"<ol> <li> <p>API Gateway (Rust):</p> <ul> <li>Centralized service for routing API requests and enforcing authentication and authorization.</li> <li>Routes requests to appropriate services, including Payment Service, Customer Service, and Merchant   Service.</li> </ul> </li> <li> <p>Merchant Dashboard (Frontend):</p> <ul> <li>Built with Next.js for an interactive, real-time dashboard where merchants can manage transactions, request   payouts, and access reports.</li> </ul> </li> <li> <p>Microservices:</p> <ul> <li>Payment Service: Manages payment initiation, status checks, and error handling.</li> <li>Customer Service: Manages customer actions, including payment setup and subscriptions.</li> <li>Merchant Service: Handles merchant account details, API key issuance, and other business logic.</li> <li>Webhook Service: Dedicated service for sending real-time notifications to external systems.</li> </ul> </li> <li> <p>Database (PostgreSQL):</p> <ul> <li>Primary storage with support for structured data, multi-tenancy, and full-text search.</li> </ul> </li> <li> <p>Storage Service (Minio):</p> <ul> <li>Stores immutable data such as receipts, invoices, proof-of-purchase PDFs, user-uploaded documents, and backups.</li> </ul> </li> </ol>"},{"location":"ARC42/#component-diagram","title":"Component Diagram","text":"<pre><code>graph TD\n    A[API Gateway] --&gt; B[Payment Service]\n    A --&gt; C[Merchant Service]\n    A --&gt; D[Customer Service]\n    A --&gt; E[Webhook Service]\n    B --&gt; F[PostgreSQL]\n    C --&gt; F\n    D --&gt; F\n    E --&gt; F\n    B --&gt; G[Minio Storage]\n    C --&gt; G\n    D --&gt; G\n    E --&gt; G\n    H[\"Frontend (Next.js)\"] --&gt; A</code></pre>"},{"location":"ARC42/#6-runtime-view","title":"6. Runtime View","text":""},{"location":"ARC42/#example-workflow-payment-process","title":"Example Workflow: Payment Process","text":"<ol> <li>Merchant Setup: A merchant creates an account, obtains API credentials, and configures payment settings.</li> <li>Payment Initiation:<ul> <li>A customer initiates payment via the merchant\u2019s platform, triggering an API call to the Payment Service.</li> <li>The API Gateway routes the request to the appropriate service.</li> </ul> </li> <li>Payment Processing:<ul> <li>Upon confirmation, the transaction is recorded in the PostgreSQL ledger, maintaining a double-entry for debit   and credit.</li> <li>The Payment Service sends a real-time update to the merchant's dashboard and, if applicable, a webhook to   external systems.</li> </ul> </li> </ol>"},{"location":"ARC42/#runtime-diagram","title":"Runtime Diagram","text":"<pre><code>sequenceDiagram\n    participant Merchant\n    participant API_Gateway\n    participant Payment_Service\n    participant Payment_Provider\n    participant PostgreSQL\n    Merchant -&gt;&gt; API_Gateway: Initiate Payment\n    API_Gateway -&gt;&gt; Payment_Service: Process Payment Request\n    Payment_Service -&gt;&gt; Payment_Provider: API Request\n    Payment_Provider --&gt;&gt; Payment_Service: Confirm Payment\n    Payment_Service -&gt;&gt; PostgreSQL: Record Transaction\n    Payment_Service --&gt;&gt; API_Gateway: Success Response\n    API_Gateway --&gt;&gt; Merchant: Payment Confirmed</code></pre>"},{"location":"ARC42/#7-deployment-view","title":"7. Deployment View","text":""},{"location":"ARC42/#infrastructure-components","title":"Infrastructure Components","text":"<ol> <li>Kubernetes Cluster: EKS or GKE, with separate namespaces for dev, staging, and production.</li> <li>Service Pods: Each microservice (e.g., Payment Service, Webhook Service) is deployed as a separate pod, managed    by Helm.</li> <li>PostgreSQL: Cloud-hosted database (Neon.tech for PoC, AWS RDS for production).</li> <li>S3 Storage (Minio): S3-compatible storage for immutable data management, optionally connected to a CDN.</li> <li>Authentication: Keycloak for centralized user and service authentication.</li> </ol>"},{"location":"ARC42/#deployment-diagram","title":"Deployment Diagram","text":"<pre><code>graph LR\n    A[Kubernetes Cluster]\n    A --&gt; B[Namespace: Dev]\n    A --&gt; C[Namespace: Staging]\n    A --&gt; D[Namespace: Production]\n    D --&gt; E[API Gateway]\n    D --&gt; F[Payment Service]\n    D --&gt; G[Merchant Service]\n    D --&gt; H[PostgreSQL]\n    D --&gt; I[S3 Storage]\n    D --&gt; J[Webhook Service]\n    D --&gt; K[Keycloak]</code></pre>"},{"location":"ARC42/#8-cross-cutting-concerns","title":"8. Cross-Cutting Concerns","text":""},{"location":"ARC42/#security","title":"Security","text":"<ul> <li>API Security: JWT for user access, API keys for merchant integrations, and secure header validation.</li> <li>Encryption: HTTPS for all data transfer, with mTLS within Kubernetes for secure service-to-service communication.</li> <li>RBAC: Permissions tailored for admins, merchants, and clients.</li> </ul>"},{"location":"ARC42/#logging-and-monitoring","title":"Logging and Monitoring","text":"<ul> <li>Sentry: Captures errors and exceptions for debugging.</li> <li>Prometheus and Grafana: Used to monitor database performance, API response times, and memory/CPU utilization for   each pod.</li> </ul>"},{"location":"ARC42/#error-handling","title":"Error Handling","text":"<ul> <li>Global Error Handling: Centralized error handling for all services.</li> <li>Circuit Breakers: Prevents cascading failures in case of issues with external payment providers.</li> </ul>"},{"location":"ARC42/#ssdlc-practices_1","title":"SSDLC Practices","text":"<ul> <li>Automated Code Scans: Integrate tools like RustSec for dependency analysis.</li> <li>Runtime Security Monitoring: Use Falco or similar tools to detect abnormal behavior in Kubernetes.</li> <li>Periodic Penetration Testing: Ensure external-facing services are secure against known vulnerabilities.</li> </ul>"},{"location":"ARC42/#9-architectural-decisions","title":"9. Architectural Decisions","text":"<ol> <li>Rust for Backend: Ensures high performance, low memory usage, and secure code.</li> <li>PostgreSQL as Main Database: Structured data storage with multi-tenant support, using schema separation for    tenant data.</li> <li>Minio for Storage: S3 compatibility for immutable asset management, simplifying CDN integration.</li> <li>Helm and Kubernetes: Effective for managing different environments (dev, staging, production) with easy scaling.</li> </ol>"},{"location":"ARC42/#10-quality-requirements","title":"10. Quality Requirements","text":""},{"location":"ARC42/#performance","title":"Performance","text":"<ul> <li>Response Time: Average API response within 200-300ms.</li> <li>Scalability: Scale pods horizontally based on demand.</li> </ul>"},{"location":"ARC42/#security_1","title":"Security","text":"<ul> <li>Data Encryption: HTTPS and mTLS within Kubernetes.</li> <li>Regular Audits: Security audits for code and infrastructure.</li> </ul>"},{"location":"ARC42/#availability","title":"Availability","text":"<ul> <li>Target: 99.9% uptime, leveraging Kubernetes autoscaling and failover mechanisms.</li> </ul>"},{"location":"ARC42/#11-risks-and-technical-debt","title":"11. Risks and Technical Debt","text":"<ol> <li>Dependency on Payment Providers: Reliance on MTN and Orange APIs may introduce availability risks.</li> <li>Scaling PostgreSQL: Potential performance limitations as data grows, requiring sharding or indexing strategies.</li> <li>Eventual Consistency: Asynchronous processing could lead to temporary inconsistencies; monitoring and retries are    required.</li> </ol>"},{"location":"ARC42/#12-glossary","title":"12. Glossary","text":"<ul> <li>MoMo: MTN Mobile Money service for local transactions.</li> <li>Double-entry Ledger: System to log each transaction with both debit and credit for accuracy.</li> <li>Merchant: Business entity using the platform for payment processing.</li> <li>Payout: Process by which funds are transferred from the platform to the merchant.</li> </ul>"},{"location":"tech/","title":"Docs","text":""},{"location":"tech/#technical-resume-for-iwym","title":"Technical Resume for IWYM","text":""},{"location":"tech/#project-overview","title":"Project Overview","text":"<p>The local payment processor solution aims to create a Stripe-like system tailored for the Cameroonian market, enabling merchants to accept payments via local mobile money providers such as MTN Mobile Money and Orange Money. The platform supports both RESTful and RPC APIs, offering scalability, security, and efficiency to merchants and developers.</p>"},{"location":"tech/#core-technical-features","title":"Core Technical Features","text":""},{"location":"tech/#backend","title":"Backend","text":"<ul> <li>Framework: Fully built using Rust for high performance and memory safety.</li> <li>API Design:<ul> <li>RPC API: Optimized for internal and trusted high-performance clients, using CBOR for compact payloads.</li> <li>Webhooks: Real-time notifications for payment status updates and external events.</li> <li>Websockets: For real-time transaction updates and notifications.</li> </ul> </li> <li>Authentication:<ul> <li>Keycloak: Centralized authentication and authorization management.</li> <li>JWT tokens for user sessions.</li> <li>API keys for merchant access.</li> </ul> </li> <li>Database:<ul> <li>PostgreSQL: Robust relational database for structured data and multi-tenancy support.</li> <li>Features include schema separation for tenant data and indexing for high-performance queries.</li> </ul> </li> <li>Asynchronous Processing:<ul> <li>Event-Driven Architecture: Handles long-running and external API calls with internal async tasks.</li> </ul> </li> <li>Immutable Data Storage:<ul> <li>Minio (S3-compatible): Stores receipts, invoices, proof-of-purchase PDFs, user-uploaded documents, and   snapshots.</li> </ul> </li> </ul>"},{"location":"tech/#frontend","title":"Frontend","text":"<ul> <li>Framework: Built with Next.js for a fast and interactive merchant dashboard.</li> <li>Features:<ul> <li>Real-time transaction updates.</li> <li>Tools for managing accounts, initiating payouts, and accessing reports.</li> <li>Responsive and user-friendly interface.</li> </ul> </li> </ul>"},{"location":"tech/#infrastructure","title":"Infrastructure","text":"<ul> <li>Kubernetes (EKS or GKE):<ul> <li>Container orchestration for deployment, scaling, and management.</li> <li>Separate namespaces for dev, staging, and production environments.</li> </ul> </li> <li>Docker:<ul> <li>Ensures reproducible development environments.</li> </ul> </li> <li>Monitoring and Logging:<ul> <li>Prometheus and Grafana: For metrics and visualizations.</li> <li>Sentry: Centralized error tracking and debugging.</li> </ul> </li> <li>Storage:<ul> <li>Minio integrated with optional CDN for efficient asset delivery.</li> </ul> </li> </ul>"},{"location":"tech/#security","title":"Security","text":"<ul> <li>Encryption:<ul> <li>HTTPS for all data transfer.</li> <li>mTLS for service-to-service communication within Kubernetes.</li> </ul> </li> <li>Role-Based Access Control (RBAC):<ul> <li>Tailored roles for admins, merchants, and customers.</li> </ul> </li> <li>SSDLC Practices:<ul> <li>Automated code scans (RustSec, Clippy).</li> <li>Secure code reviews and threat modeling.</li> <li>Continuous penetration testing.</li> </ul> </li> </ul>"},{"location":"tech/#key-ideas-and-concepts","title":"Key Ideas and Concepts","text":""},{"location":"tech/#dual-api-system","title":"Dual API System","text":"<ul> <li>REST API:<ul> <li>Serves as the standard interface for external clients.</li> <li>Follows OpenAPI specifications to ensure clarity and documentation.</li> </ul> </li> <li>RPC API:<ul> <li>Provides a single endpoint (<code>/rpc</code>) for compact, CBOR-encoded payloads.</li> <li>Supports batching requests (<code>/rpc.batch</code>) for optimized client-server interactions.</li> </ul> </li> </ul>"},{"location":"tech/#multi-tenancy-architecture","title":"Multi-Tenancy Architecture","text":"<ul> <li>Tenant isolation using PostgreSQL schema separation.</li> <li>Scalable to support thousands of merchants without impacting performance.</li> </ul>"},{"location":"tech/#event-driven-architecture","title":"Event-Driven Architecture","text":"<ul> <li>Asynchronous tasks for:<ul> <li>Payment status updates.</li> <li>Webhook notifications.</li> <li>External API integrations (e.g., MTN, Orange Money).</li> </ul> </li> </ul>"},{"location":"tech/#storage-strategy","title":"Storage Strategy","text":"<ul> <li>Minio for immutable data storage:<ul> <li>Ensures receipts, invoices, and documents remain tamper-proof.</li> <li>Efficient integration with the backend for automated uploads.</li> </ul> </li> </ul>"},{"location":"tech/#monitoring-and-resilience","title":"Monitoring and Resilience","text":"<ul> <li>Kubernetes HPA (Horizontal Pod Autoscaler) for dynamic scaling based on traffic and load.</li> <li>Circuit breakers and retries for external API failures to ensure system stability.</li> </ul>"},{"location":"tech/#technology-stack","title":"Technology Stack","text":"Component Technology Rationale Backend Rust High performance, low memory footprint, and safety. Frontend Next.js SEO-friendly, responsive, and interactive. Database PostgreSQL Structured data storage with multi-tenancy support. Authentication Keycloak Centralized and flexible identity management. Storage Minio S3-compatible storage for immutable data. Orchestration Kubernetes (EKS/GKE) Scalability, fault tolerance, and resource optimization. Monitoring Prometheus/Grafana Comprehensive metrics and visualization. Error Tracking Sentry Centralized error tracking for proactive debugging. Development Tools Docker Reproducible environments for development and CI/CD."},{"location":"tech/#core-features-summary","title":"Core Features Summary","text":"<ol> <li> <p>High Performance:</p> <ul> <li>Rust backend optimized for speed and low latency.</li> <li>CBOR encoding for compact RPC payloads.</li> </ul> </li> <li> <p>Flexibility:</p> <ul> <li>REST API for compatibility and RPC API for performance.</li> <li>Multi-tenancy for scalable merchant onboarding.</li> </ul> </li> <li> <p>Security:</p> <ul> <li>Keycloak for centralized authentication.</li> <li>Full encryption and RBAC enforcement.</li> </ul> </li> <li> <p>Scalability:</p> <ul> <li>Kubernetes orchestration for horizontal scaling.</li> <li>Separate namespaces for dev, staging, and production.</li> </ul> </li> <li> <p>Developer Tools:</p> <ul> <li>Docker for consistent environments.</li> <li>Automated code scanning and secure code practices.</li> </ul> </li> <li> <p>Resilience:</p> <ul> <li>Circuit breakers for external API dependencies.</li> <li>Robust error handling and logging.</li> </ul> </li> </ol>"},{"location":"tech/#conclusion","title":"Conclusion","text":"<p>This technical framework ensures the local payment processor is secure, scalable, and performant, meeting the needs of merchants in Cameroon while laying the foundation for future expansion. By leveraging modern frameworks and practices, the project is designed to handle high transaction volumes with minimal latency and strong reliability.</p>"}]}